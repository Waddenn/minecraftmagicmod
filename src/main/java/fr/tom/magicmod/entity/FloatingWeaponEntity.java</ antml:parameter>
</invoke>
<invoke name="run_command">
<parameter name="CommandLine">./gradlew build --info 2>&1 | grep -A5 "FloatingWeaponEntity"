package fr.tom.magicmod.entity;

import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import net.minecraft.world.phys.Vec3;
import net.minecraft.nbt.Tag;
import net.minecraft.network.syncher.SynchedEntityData;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.core.particles.ParticleTypes;
import net.minecraft.world.phys.AABB;

import java.util.List;
import java.util.UUID;

public class FloatingWeaponEntity extends Entity {
    private UUID ownerUUID;
    private int orbitIndex = 0;
    private float orbitAngle = 0;
    private static final float ORBIT_RADIUS = 2.0f;
    private static final float ORBIT_SPEED = 0.08f;
    private static final float DAMAGE = 4.0f;
    
    public FloatingWeaponEntity(EntityType<?> type, Level level) {
        super(type, level);
        this.noPhysics = true;
    }
    
    public void setOwner(Player player) {
        this.ownerUUID = player.getUUID();
    }
    
    public void setOrbitIndex(int index) {
        this.orbitIndex = index;
        this.orbitAngle = (float) (index * (Math.PI * 2 / 5.0)); // Distribute 5 weapons evenly
    }
    
    @Override
    public void tick() {
        super.tick();
        
        if (!level().isClientSide()) {
            Player owner = getOwner();
            
            // Despawn if owner is invalid
            if (owner == null || !owner.isAlive() || owner.distanceTo(this) > 32.0) {
                this.discard();
                return;
            }
            
            // Update orbit position
            orbitAngle += ORBIT_SPEED;
            if (orbitAngle > Math.PI * 2) {
                orbitAngle -= Math.PI * 2;
            }
            
            // Calculate position around player
            double x = owner.getX() + Math.cos(orbitAngle) * ORBIT_RADIUS;
            double y = owner.getY() + 1.5 + Math.sin(orbitAngle * 3) * 0.3; // Sine wave height
            double z = owner.getZ() + Math.sin(orbitAngle) * ORBIT_RADIUS;
            
            this.setPos(x, y, z);
            
            // Damage nearby hostile mobs
            AABB damageBox = this.getBoundingBox().inflate(0.5);
            List<LivingEntity> nearbyMobs = level().getEntitiesOfClass(LivingEntity.class, damageBox);
            
            for (LivingEntity mob : nearbyMobs) {
                if (mob != owner && mob.isAlive() && !isAllied(mob, owner)) {
                    mob.hurt(level().damageSources().playerAttack(owner), DAMAGE);
                    // Knockback
                    Vec3 direction = mob.position().subtract(owner.position()).normalize();
                    mob.setDeltaMovement(mob.getDeltaMovement().add(direction.scale(0.3)));
                    
                    // Visual feedback
                    level().addParticle(ParticleTypes.SWEEP_ATTACK, 
                        this.getX(), this.getY(), this.getZ(), 0, 0, 0);
                }
            }
        } else {
            // Client-side particles
            if (random.nextFloat() < 0.3) {
                level().addParticle(ParticleTypes.ENCHANT,
                    this.getX() + (random.nextDouble() - 0.5) * 0.3,
                    this.getY() + (random.nextDouble() - 0.5) * 0.3,
                    this.getZ() + (random.nextDouble() - 0.5) * 0.3,
                    0, 0.05, 0);
            }
        }
    }
    
    private boolean isAllied(LivingEntity entity, Player owner) {
        if (entity instanceof Player) {
            return true; // Don't attack other players
        }
        if (entity.getTeam() != null && owner.getTeam() != null) {
            return entity.getTeam().equals(owner.getTeam());
        }
        return false;
    }
    
    public Player getOwner() {
        if (ownerUUID != null && level() != null) {
            return level().getPlayerByUUID(ownerUUID);
        }
        return null;
    }
    
    @Override
    protected void defineSynchedData(SynchedEntityData.Builder builder) {
        // No synched data needed
    }
    
    @Override
    protected void saveAdditional(Tag tag, net.minecraft.core.HolderLookup.Provider provider) {
        // Transient entity - no persistence needed
    }
    
    @Override
    protected void loadAdditional(Tag tag, net.minecraft.core.HolderLookup.Provider provider) {
        // Transient entity - no persistence needed
    }
}
